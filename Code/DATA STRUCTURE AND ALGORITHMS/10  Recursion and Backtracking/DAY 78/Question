## **Word Search Problem**

**Difficulty:** Medium  
**Accuracy:** 32.69%  
**Submissions:** 58K+  
**Points:** 4

---

## **Problem Statement**

You are given a **2D grid** `mat[][]` of size **n Ã— m**, filled with **English alphabets**, and a **string `word`**.  
Check if the **word** exists in the grid.

âœ… The word can be formed by moving **horizontally or vertically** (not diagonally).  
âœ… The **same cell cannot be used more than once** in a word search path.

---

## **Examples**

### **Example 1**

#### **Input:**

```plaintext
mat = [['T', 'E', 'E'],
       ['S', 'G', 'K'],
       ['T', 'E', 'L']]
word = "GEEK"
```

#### **Output:**

```plaintext
true
```

#### **Explanation:**

The word **GEEK** can be formed by moving through the following path:  
`(1,1) â†’ (1,2) â†’ (2,2) â†’ (0,2)`

---

### **Example 2**

#### **Input:**

```plaintext
mat = [['T', 'E', 'U'],
       ['S', 'G', 'K'],
       ['T', 'E', 'L']]
word = "GEEK"
```

#### **Output:**

```plaintext
false
```

#### **Explanation:**

There is no valid path to form "GEEK".

---

### **Example 3**

#### **Input:**

```plaintext
mat = [['A', 'B', 'A'],
       ['B', 'A', 'B']]
word = "AB"
```

#### **Output:**

```plaintext
true
```

#### **Explanation:**

There are multiple valid paths to form "AB".

---

## **Constraints**

- `1 â‰¤ n, m â‰¤ 6` (Small grid size)
- `1 â‰¤ L â‰¤ 15` (Word length)
- `mat[][]` and `word` consist of **only uppercase and lowercase English letters**.

---

## **Approach: Backtracking with DFS**

### **Why DFS & Backtracking?**

Since we can move **only horizontally or vertically**, we can **explore all possible paths recursively** using **Depth First Search (DFS)**.

#### **Algorithm:**

1. **Find the starting character:**
   - Traverse the `mat[][]` to locate **all** positions where the **first character of `word`** is found.
2. **Use DFS to explore adjacent cells:**
   - Move in **4 directions** â†’ `up, down, left, right`.
   - Mark visited cells to avoid reusing them in the same path.
3. **Base case:**
   - If the index `i == len(word)`, return `True` (word found).
4. **Backtracking:**
   - If a path fails, **undo** the changes and try another direction.

## **Complexity Analysis**

- **Time Complexity:** `O(n * m * 4^L)`

  - **n Ã— m**: We start DFS from every cell in the grid.
  - **4^L**: Each DFS step has 4 possible moves.
  - **Pruning:** If a character doesnâ€™t match, we stop exploring that path early.

- **Space Complexity:** `O(n Ã— m) + O(L)`
  - `O(n Ã— m)`: `visited[][]` matrix.
  - `O(L)`: Recursive stack depth (max `L`).

---

## **Key Takeaways**

âœ… **DFS with Backtracking** is the best approach to solve this problem.  
âœ… **Grid traversal** is optimized by pruning paths early.  
âœ… **Time complexity is manageable** since `n, m â‰¤ 6`.  
âœ… **Edge cases are handled** (small grid, single-character words, multiple solutions).

ðŸš€ **Efficiently finds if a word exists in a grid!**
