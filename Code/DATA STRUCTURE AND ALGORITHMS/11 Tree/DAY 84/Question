### **Inorder Traversal of a Binary Tree**

**Difficulty:** Easy  
**Accuracy:** 67.15%  
**Submissions:** 172K+  
**Points:** 2

---

### **Problem Statement:**

Given a **Binary Tree**, your task is to return its **In-Order Traversal**.

**Inorder Traversal:**

- **First**, visit the left subtree.
- **Then**, visit the root node.
- **Finally**, visit the right subtree.

---

### **Examples:**

#### **Example 1:**

**Input:**

```
root[] = [1, 2, 3, 4, 5]
```

**Tree Structure:**

```
       1
      / \
     2   3
    / \
   4   5
```

**Output:**

```
[4, 2, 5, 1, 3]
```

**Explanation:**

- Left Subtree: `4, 2, 5`
- Root: `1`
- Right Subtree: `3`

Final **inorder traversal**: **[4, 2, 5, 1, 3]**.

---

#### **Example 2:**

**Input:**

```
root[] = [8, 1, 5, N, 7, 10, 6, N, 10, 6]
```

**Tree Structure:**

```
        8
       / \
      1   5
       \  / \
        7 10 6
         \
         10
```

**Output:**

```
[1, 7, 10, 8, 6, 10, 5, 6]
```

**Explanation:**

- Left Subtree: `1, 7, 10`
- Root: `8`
- Right Subtree: `6, 10, 5, 6`

Final **inorder traversal**: **[1, 7, 10, 8, 6, 10, 5, 6]**.

---

### **Constraints:**

- `1 ≤ number of nodes ≤ 10^5`
- `0 ≤ node->data ≤ 10^5`
